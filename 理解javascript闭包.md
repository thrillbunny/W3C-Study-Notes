# JS学习笔记-理解javascript原型和作用域系列
---

博文原作者 王福朋

博文地址  [理解javascript原型和作用域系列](https://www.cnblogs.com/wangfupeng1988/p/3977924.html)

老师讲得很有自己想法，但分的章节较多，每篇篇幅比较少，所以这里针对我学习所得新知和我认为比较难的点画一个重点，并写出我自己的理解和补充。

---

## 1 一切皆对象

> 上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)等都是对象。他们都是引用类型。

> 判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。

**注：关于引用类型具体详见红皮书第5章，老师的博文中实际只提出了几种引用类型。**

> javascript中的对象可以任意的扩展属性，没有class的约束。函数和数组不能像自定义 Object 那样定义属性，但可以采用其他方法。方法见下：

	var fn = function () {
	            alert(100);
	        };
	        fn.a = 10;
	        fn.b = function () {
	            alert(123);
	        };
	        fn.c = {
	            name: "王福朋",
	            year: 1988
	        }; 

> 总之函数/数组之流，只要是对象，它就是**属性的集合**。

可以参考我保存的一篇博客文章：深入学习JavaScript对象。


## 2 函数和对象的关系

> 函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑。

王福朋提出，**对象都是函数创建的**，具体看下面的代码。

    function Fn() {
        this.name = '王福朋';
        this.year = 1988;
    }
    var fn1 = new Fn();   // 1

	var obj = { a: 10, b: 20 }; // 2
	var arr = [5, 'x', true]; // 3

2和3本质是 js 的一种语法糖，等价于：

	//var obj = { a: 10, b: 20 };
    //var arr = [5, 'x', true];

    var obj = new Object();
    obj.a = 10;
    obj.b = 20;

    var arr = new Array();
    arr[0] = 5;
    arr[1] = 'x';
    arr[2] = true;

	console.log(typeof (Object));  // function
	console.log(typeof (Array));  // function

	console.log(typeof (obj));  // object
	console.log(typeof (arr));  // object

**划重点！**

**重点1**

**typeof (Object) === "function"**

**typeof (Array) === "function"**

**重点2(与本文存在出入）**

**红皮书第五章 P84 提出：**

> **在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（ Firefox 2 及
更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）。**

**这里和本文的分歧点是为什么呢？**

我自己的观点是，能被 new 创建对象实例的都是构造函数，所以 Object 和 Array 的 type 是 function。而 obj 和 arr 是构造函数新建出的实例引用对象，所以 typeof 结果是 object（instanceof 能够 判断具体的引用类型）。

这篇文章下面有个评论我觉得挺全面的，在此做个摘录：

> 所有对象的创建都需要通过一个构造函数，虽然通过一个语法糖可以省略掉构造函数，但构造函数是确实存在的。构造函数本身也是一个对象，我们可以称之为**函数对象**，函数对象也可以通过它的构造函数**Function()**来创建。JavaScript内置不少函数对象，如Object、String、Array、Function等，它们既是对象，也可以作为构造函数用来构造其它的对象。除此之外，我们也可以定义自己的构造函数。

## 3 原型链

原型链这几章我后续整理，目前还没有复习到，直接看博文容易失去自己的判断力。我记得我之前看过一张图表，具体写了原型链、prototype 和 \__proto__ 之间的关系，不知道还能不能找到那张表。

## 4 自由变量和作用域

自由变量：在A作用域中使用的变量 x ，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x 就是一个自由变量，如图1所示：

![](https://images0.cnblogs.com/blog/138012/201409/251447094515754.png)

而函数体内的**自由变量值**是在**函数定义**时确定的，而不是函数调用时确定。

看图2的实例：

![](https://images0.cnblogs.com/blog/138012/201409/251447377485132.png)

所以针对图1中自由变量 x 的取值，准确来说应该是：

> 到**定义**这个函数的那个作用域中取**自由变量值**（仅限自由变量），即要到定义 fn 函数的那个作用域中取，无论 fn 函数将在哪里调用。

这也可以解释图2结果，fn 中自由变量x实际在一开始函数定义时就确定了。

## 5 作用域和执行上下文

执行上下文有篇更好的博文，之后作补充。

> 与全局作用域不同，函数在**定义**的时候（不是调用的时候），就已经确定了函数体内自由变量的作用域。（具体案例见 4 自由变量和作用域）

![](https://images0.cnblogs.com/blog/138012/201409/230841277489133.png)

> 函数每被调用一次，都会产生一个新的执行上下文环境。执行上下文是调用函数时产生的，例如一个函数被循环调用了100次，那么在这个过程中会产生100个执行上下文环境（参数不同）。而作用域是在函数创建时就产生的，同一个作用域下可能同时存在不同的执行上下文。

> 而在加载程序（程序调用）时，就已经确定了全局上下文环境。



**[深入理解javascript原型和闭包（13）-【作用域】和【上下文环境】](http://www.cnblogs.com/wangfupeng1988/p/3991995.html)**

这篇把作用域（全局和函数作用域）、执行上下文（全局上下文、函数上下文）以及执行上下文的入栈和出栈（上下文环境出栈就会被及时销毁、释放内存）的具体流程讲了一遍，很清楚。

作用域只是一个“地盘”，一个抽象的概念，只有变量声明没有变量定义，要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。

如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。

## 6 闭包

闭包应用的两种典型情况（异步中也会用到，如函数中调用 setTimeout：

1）函数作为返回值

	function fn() {
		var max = 10;
		return function bar(x) {
			if(x > max) {
				console.log(x);
			}
		}
	}
	
	var f1 = fn(); // 获取返回的函数 bar
	f1(15); // 执行bar()

2）函数作为参数传递

	var max = 10;
	var fn = function(x) {
		if(x > max) {
			console.log(x);
		}
	}
	
	(function(f) {
		var max = 100;
		f(15);
	})(fn);  // 15

这里结果是 15 ，因为 max 值并非 100 ，而是 fn 定义时获取的 10 。详情见 *4 自由变量和作用域*。

异步函数中也会用到，如函数中调用 setTimeout。

闭包会使得父函数在调用完成之后，其执行上下文环境不会被销毁，依然存在于执行上下文栈中，因为子函数的自由变量需向创建这一子函数的作用域中查找。
