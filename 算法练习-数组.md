# 算法练习-数组
---

## 1. 构建乘积数组

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]。不能使用除法。

题目理解：构建新数组B，B中每一项为不包含其项索引对应的A数组项的其余数的乘积，B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]（注意里面没有 A[i]）。

	function multiply(array)
	{
	    // write code here
	    var length = array.length, B = [], temp = [];
	    
		// 特殊情况，返回空数组
	    if(length == 0) {
	        return B;
	    }

		// 构建一个数组B，B=[1,A[0],A[0]*A[1],A[0]*A[1]*A[2],…,A[0]*A[1]*A[2]*…*A[n-2]]
	    B[0] = 1;
	    for(var i = 1; i < length; i++) {
	        B[i] = array[i-1] * B[i-1];
	    }
	    
		// 构建一个数组temp，temp=[1,A[n-1],A[n-1]*A[n-2],A[n-1]*A[n-2]*A[n-3],…,A[n-1]*A[n-2]*A[n-3]*…*A[2]*A[1]]
	    temp[0] = 1;
	    for(var j = 1; j < length; j++) {
	        temp[j] = array[length - j] * temp[j-1];
	    }
	    
	    for(var k = 0; k < length; k++) {
	        B[k] = B[k] * temp[length - 1 - k];
	    }
	    
	    return B;
	}

这里新建了两个长为 array.length 的数组，有没有办法降低空间复杂度，只用一个数组？

## 2. 数组中重复的数字

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

###解法1 indexOf 索引判定

	function duplicate(numbers, duplication)
	{
	    // write code here
	    //这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
	    //函数返回True/False
	    var length = numbers.length, i = 0;
	    
	    while(i < length) {
	        if(numbers.indexOf(numbers[i]) !== numbers.lastIndexOf(numbers[i])) {
	            duplication[0] = numbers[i];
	            return true;
	        }
	        else {
	            i++;
	        }
	    }
	    
	    return false;
	}

###解法2 构建辅助数组计数实现

该方法自我感觉用 JavaSript 不是很合适。

###解法3 基数排序法

O(1)空间和O(n)时间复杂度。

![基数排序算法](http://img.blog.csdn.net/20150219205448929)


#[具体实现](https://www.cnblogs.com/Czc963239044/p/6961511.html)

 
因为基数排序我目前还没有学过，就暂且放在这里。


## 3. 二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**采用双指针，以右上角为判定点**


	function Find(target, array)
	{
	    // write code here
	    
	    // js二维数组表示方式
	    // var arr1=[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
	    
	    var rowLength = array.length;
	    var colLength = array[0].length;
	    
	    // 左上和右下必然是最小和最大数
	    if(target < array[0][0] || target > array[rowLength-1][colLength-1]) {
	        return false;
	    }
	    
	    // 双指针判定
	    var i = 0, j = colLength-1;
	    while(i<rowLength && j >=0) {
	        if(target === array[i][j]) {
	            return true;
	        } else if(target < array[i][j]){
	            j--;
	        } else if(target > array[i][j]){
	            i++;
	        }
	    }
	    
	    return false;
	}

这道题开始时我错误理解了意思，实际上不能保证第一行的所有数都小于第二行，只能保证数据按行递增，按列递增。

仔细思考了下，以**右上**为起始点是最便捷的，我也写过以左上最小值为起始点的程序，但显然没有右上这个接近中值的数据便捷。

双指针实际是在缩小包围圈，如果 target > 判定点，则表示 target 比判定点所在的每一行都大，去除掉 判定点 所在的 **行**；如果 target < 判定点，则表示 target 比判定点所在的每一行都小，去除掉 判定点 所在的 **列**。用一张别人的做图表示：

![包围圈缩小](https://img-blog.csdn.net/201807201033365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjc3MDMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 3. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。