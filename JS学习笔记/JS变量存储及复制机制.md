# 变量及作用域问题
---

**声明** 

本篇基本脉络依据红皮书《JavaScript高级程序设计》，部分内容有摘录。


## 1 变量存储

首先复习下两个基本概念：

1）基本类型和引用类型

基本数据类型： Number、String、Boolean、Null、Undefined

引用数据类型： Object、Array、Function

2）堆和栈

**栈（stack）**：

主要表现为一种数据结构，是只能在某一端插入和删除的特殊线性表。

它按照后进先出（LIFO）的原则存储数据,先进入的数据被压入栈底，最后的数据在栈顶，栈顶允许进行数据的插入和删除操作；栈底固定，而栈顶浮动；栈中元素个数为零时，称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

**堆（heap）**：

在程序中，堆用于动态分配和释放程序所使用的对象，可以被看成是一种树形数据结构。在以下情况中调用堆操作：

1.事先不知道程序所需对象的数量和大小。

2.对象太大，不适合使用堆栈分配器。

堆使用运行期间分配给代码和堆栈以外的部分内存。JS开发人员不能直接操作堆区，堆区数据由JS引擎操作完成。

（堆和栈的具体区别另述）

结合下图分析：

![变量存储-图来自网络](https://images2015.cnblogs.com/blog/606186/201511/606186-20151116175218593-917241572.png)

JavaScript中变量在**内存中的存储**包括以下几点：

- 变量标识（即变量名，如上图中的Str）：存储在内存的栈区
- 基本类型的变量值（如Str的值souvenir）和指向引用类型的指针（指向存储在堆中的实际对象，如obj1对象的指向堆区地址）：存储在内存的栈区
- 引用类型（即对象）：存储在堆区

在JavaScript中，引用类型存储在堆区，因为在JavaScript中，一切都是对象，对象可以进行扩展，放置在堆中可以进行不断的扩展，如果放在内存中就会消耗大量资源。

查询引用类型时，首先需要从栈中读取其内存地址，然后再根据地址指针找到保存在堆内存中的值，所以放置在堆中的数据的查询效率比较低。

> 栈存取速度比堆要快，仅次于直接位于CPU中的寄存器，但由于存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆可以动态地分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动收走不再使用的数据，但由于在运行时动态分配内存，所以存取速度较慢。

> 对于基本数据类型而言，他们占用内存比较小，如果放在堆中，查找会浪费很多时间，而把堆中的数据放入栈中也会影响栈的效率，所以把消耗资源较多的引用类型数据，放在可以动态分配大小的堆中。

## 2 变量复制

对于基本类型而言，从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。

	var num1 = 5;
	var num2 = num1; // 5

num2 中的 5 与 num1 中的 5 是完全独立的。

对于引用类型而言，当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在栈区的值复制一份放到为新变量分配的栈区空间中。不同的是，这个值的副本实际上是一个**指针**，而这个指针指向存储在**堆**中的一个对象。

	var object1 = {}；
	var object2 = object1;
	object2.name = "Mike";
	console.log(object1.name);  // "Mike"

![引用类型复制-图来自网络](https://img-blog.csdn.net/20160424000716861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 3 参数传递

> ECMAScript 中所有函数的参数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。

向参数传递基本类型的值时，将该值复制给接收的参数，传递引用类型的值时，将值在内存中的**地址**复制给接收的参数，所以对该局部变量参数的改动会反映到函数外部。

	function setName(obj) {
		obj.name = "Mike";
	}
	
	var person = { name: "Sandy" };
	setName(person);
	console.log(person.name); // "Mike"

当在函数内部为 obj 修改 name 属性后，函数外部的 person 也将有所反映，因为 person 指向的对象在堆内存中只有一个，但这并不代表参数是按引用传递的。

## 引申 变量提升

	var a = 100;
	 
	function func(){
	    console.log(a);
	    var a=200;
	    console.log(a);
	}
	 
	func();

	// undefined
	// 200

第一个 console.log(a) 结果为 undefined，可能按照通常的作用域链思维去想，此时的 a 还未定义，局部变量查找不到 a 变量的话应该去全局作用域查找，但实际运行结果并非如此，这里就涉及预解析、变量和函数声明提升的概念。

遇到 script 标签的话 js 就会进行预解析，将变量 var 和 function 声明提升，但不会执行 function，然后就进入上下文执行，上下文执行还是执行预解析同样操作，直到没有 var 和 function，就开始执行上下文。

上面的 demo 就等同于：

	function func() {} // 函数声明提升在变量提升之前
	var a;

	a = 100;

	function func(){
		var a；

	    console.log(a); // undefined

	    a=200;

	    console.log(a); // 200
	}
	 
	func();

---
# 参考

[JavaScript变量存储浅析（二)](https://www.cnblogs.com/souvenir/p/4969565.html)

[JS中变量的存储问题](https://blog.csdn.net/hhthwx/article/details/78146169)
